<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotating Octahedron with Physics</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Rotating Octahedron with Physics</strong><br>
        Three balls bouncing inside with gravity
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, octahedron, balls = [], ballMeshes = [];
        const gravity = 0.003;
        const damping = 0.95;
        const ballRadius = 0.15;
        
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Create octahedron
            const octaGeo = new THREE.OctahedronGeometry(2, 0);
            const octaMat = new THREE.MeshPhongMaterial({ 
                color: 0x4a90e2,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                wireframe: false
            });
            octahedron = new THREE.Mesh(octaGeo, octaMat);
            scene.add(octahedron);
            
            // Add wireframe
            const wireGeo = new THREE.OctahedronGeometry(2, 0);
            const wireMat = new THREE.MeshBasicMaterial({ 
                color: 0x80c0ff,
                wireframe: true,
                transparent: true,
                opacity: 0.6
            });
            const wireframe = new THREE.Mesh(wireGeo, wireMat);
            octahedron.add(wireframe);
            
            // Create balls with physics properties
            const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d];
            for (let i = 0; i < 3; i++) {
                const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
                const ballMat = new THREE.MeshPhongMaterial({ color: colors[i] });
                const ballMesh = new THREE.Mesh(ballGeo, ballMat);
                
                // Small random initial positions near center
                const ball = {
                    mesh: ballMesh,
                    pos: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    ),
                    vel: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    )
                };
                
                balls.push(ball);
                ballMeshes.push(ballMesh);
                scene.add(ballMesh);
            }
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
            pointLight2.position.set(-5, -5, 5);
            scene.add(pointLight2);
            
            window.addEventListener('resize', onWindowResize);
        }
        
        function isInsideOctahedron(pos) {
            // Octahedron can be defined by 8 planes
            // For a regular octahedron centered at origin with radius 2
            const size = 2;
            const d = size / Math.sqrt(2);
            
            // Check all 8 faces
            return Math.abs(pos.x) + Math.abs(pos.y) + Math.abs(pos.z) <= d * 2;
        }
        
        function getOctahedronNormal(pos) {
            // Find which face the point is closest to and return its normal
            const eps = 0.01;
            const normal = new THREE.Vector3();
            
            // Determine which octant and face
            const sx = Math.sign(pos.x) || 1;
            const sy = Math.sign(pos.y) || 1;
            const sz = Math.sign(pos.z) || 1;
            
            normal.set(sx, sy, sz).normalize();
            return normal;
        }
        
        function updatePhysics() {
            balls.forEach(ball => {
                // Apply gravity (downward in world space)
                ball.vel.y -= gravity;
                
                // Update position
                ball.pos.add(ball.vel);
                
                // Check collision with octahedron faces
                if (!isInsideOctahedron(ball.pos)) {
                    // Find normal of closest face
                    const normal = getOctahedronNormal(ball.pos);
                    
                    // Reflect velocity
                    const dot = ball.vel.dot(normal);
                    ball.vel.sub(normal.clone().multiplyScalar(2 * dot));
                    ball.vel.multiplyScalar(damping);
                    
                    // Push ball back inside
                    while (!isInsideOctahedron(ball.pos)) {
                        ball.pos.sub(ball.vel.clone().multiplyScalar(0.01));
                    }
                }
                
                // Update mesh position
                ball.mesh.position.copy(ball.pos);
            });
            
            // Ball-to-ball collisions
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];
                    const dist = ball1.pos.distanceTo(ball2.pos);
                    const minDist = ballRadius * 2;
                    
                    if (dist < minDist) {
                        // Simple elastic collision
                        const normal = new THREE.Vector3().subVectors(ball2.pos, ball1.pos).normalize();
                        const relVel = new THREE.Vector3().subVectors(ball1.vel, ball2.vel);
                        const velAlongNormal = relVel.dot(normal);
                        
                        if (velAlongNormal > 0) continue;
                        
                        const impulse = normal.clone().multiplyScalar(velAlongNormal);
                        ball1.vel.sub(impulse);
                        ball2.vel.add(impulse);
                        
                        // Separate balls
                        const overlap = minDist - dist;
                        const separation = normal.clone().multiplyScalar(overlap * 0.5);
                        ball1.pos.sub(separation);
                        ball2.pos.add(separation);
                    }
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate octahedron
            octahedron.rotation.x += 0.005;
            octahedron.rotation.y += 0.01;
            
            // Update physics
            updatePhysics();
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
        animate();
    </script>
</body>
</html>